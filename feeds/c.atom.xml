<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>philokey的笔记</title><link href="http://www.philokey.com/" rel="alternate"></link><link href="http://www.philokey.com/feeds/c.atom.xml" rel="self"></link><id>http://www.philokey.com/</id><updated>2014-09-01T00:00:00+08:00</updated><entry><title>C++中的static</title><link href="http://www.philokey.com/pages/2014/09/01/czhong-de-static.html" rel="alternate"></link><updated>2014-09-01T00:00:00+08:00</updated><author><name>philokey</name></author><id>tag:www.philokey.com,2014-09-01:pages/2014/09/01/czhong-de-static.html</id><summary type="html">&lt;h2&gt;静态全局变量&lt;/h2&gt;
&lt;p&gt;在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量,存放在全局数据区。&lt;/p&gt;
&lt;h3&gt;全局变量和全局静态变量的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;全局变量是不显式用static修饰的全局变量，但全局变量默认是动态的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。&lt;/li&gt;
&lt;li&gt;全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;静态局部变量&lt;/h2&gt;
&lt;p&gt;在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。&lt;/p&gt;
&lt;p&gt;有时候需要在两次调用之间对变量的值进行保存。但是全局变量不易维护，所以可以使用静态局部变量。&lt;/p&gt;
&lt;p&gt;静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。&lt;/p&gt;
&lt;h3&gt;静态函数&lt;/h3&gt;
&lt;p&gt;在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。&lt;/p&gt;
&lt;p&gt;定义静态函数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态函数不能被其它文件所用；&lt;/li&gt;
&lt;li&gt;其它文件中可以定义相同名字的函数，不会发生冲突；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;class中的静态成员&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;对于类中的非静态成员，每个对象都有自己的该成员。而静态成员只创建一个副本。静态成员可以是函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;output&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每个对象都有自己的str，共享一个num&lt;/p&gt;
&lt;h3&gt;特点&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//通过类名可以调用静态成员函数&lt;/span&gt;
&lt;span class="no"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;//静态成员函数中不能引用非静态成员&lt;/span&gt;
&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象后才有内存空间，所以这个调用就出错了，就好比没有声明一个变量却提前使用它一样。&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="c1"&gt;//output定义为&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//error!  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;初始化&lt;/h2&gt;
&lt;p&gt;只有const static 的成员可以再类的声明中直接初始化。&lt;/p&gt;
&lt;p&gt;静态成员一般选择在类的实现文件中,用构造函数以进行初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//或者   &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry></feed>